[{"categories":["kubernetes"],"content":"本文介绍通过 Kubernetes Deployment 对象如何去运行一个应用. ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:0:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"一、学习目标 创建一个 nginx deployment. 使用 kubectl 列举关于 deployment 信息. 更新 deployment. 使用 go 客户端进行上述操作. 默认已经安装了 kubernetes. 如果没安装，请参考 ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:1:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"二、命令操作 ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"2.1 准备 yaml 文件 按照任务创建一个运行 nginx:1.7.9 Docker 镜像的 Deployment: apiVersion:apps/v1# for versions before 1.9.0 use apps/v1beta2kind:Deploymentmetadata:name:nginx-deploymentnamespace:testspec:selector:matchLabels:app:nginxreplicas:2# tells deployment to run 2 pods matching the templatetemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.14.2ports:- containerPort:80","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:1","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"2.2 创建 Deployment 运行 Yaml 文件创建: kubectl apply -f /XXX/document/note/Kubernetes/test/nginx/deployment.yaml 展示 Deployment 的信息: kubectl describe deployment nginx-deployment --namespace=test Name: nginx-deployment Namespace: test CreationTimestamp: Thu, 01 Oct 2020 17:12:59 +0800 Labels: \u003cnone\u003e Annotations: deployment.kubernetes.io/revision: 3 kubectl.kubernetes.io/last-applied-configuration: {\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"annotations\":{},\"name\":\"nginx-deployment\",\"namespace\":\"test\"},\"spec\":{\"replicas\":... Selector: app=nginx Replicas: 2 desired | 2 updated | 2 total | 2 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max surge Pod Template: Labels: app=nginx Containers: nginx: Image: nginx:1.14.2 Port: 80/TCP Host Port: 0/TCP Limits: memory: 200Mi Requests: memory: 100Mi Environment: \u003cnone\u003e Mounts: \u003cnone\u003e Volumes: \u003cnone\u003e Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: \u003cnone\u003e NewReplicaSet: nginx-deployment-fbb99c8b8 (2/2 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 5m6s deployment-controller Scaled up replica set nginx-deployment-865d6c94c9 to 1 Normal ScalingReplicaSet 3m43s deployment-controller Scaled down replica set nginx-deployment-74f5bf7bd9 to 1 Normal ScalingReplicaSet 3m43s deployment-controller Scaled up replica set nginx-deployment-fbb99c8b8 to 1 Normal ScalingReplicaSet 3m41s deployment-controller Scaled down replica set nginx-deployment-865d6c94c9 to 0 Normal ScalingReplicaSet 3m41s deployment-controller Scaled up replica set nginx-deployment-fbb99c8b8 to 2 Normal ScalingReplicaSet 3m38s deployment-controller Scaled down replica set nginx-deployment-74f5bf7bd9 to 0 列出创建的 pods: kubectl get pods -l app=nginx --namespace= NAME READY STATUS RESTARTS AGE nginx-deployment-fbb99c8b8-4lpwd 1/1 Running 0 5m28s nginx-deployment-fbb99c8b8-tpd4n 1/1 Running 0 5m26s 查看具体某个 pod 的信息: kubectl describe pod nginx-deployment-fbb99c8b8-4lpwd --namespace=test Name: nginx-deployment-fbb99c8b8-4lpwd Namespace: test Priority: 0 Node: minikube/192.168.64.3 Start Time: Fri, 09 Oct 2020 15:40:15 +0800 Labels: app=nginx pod-template-hash=fbb99c8b8 Annotations: \u003cnone\u003e Status: Running IP: 172.17.0.9 IPs: IP: 172.17.0.9 Controlled By: ReplicaSet/nginx-deployment-fbb99c8b8 Containers: nginx: Container ID: docker://16da80166234e8f7fdbb2e2bb7accbcc1841213cb2888af6463102675414c00d Image: nginx:1.14.2 Image ID: docker-pullable://nginx@sha256:f7988fb6c02e0ce69257d9bd9cf37ae20a60f1df7563c3a2a6abe24160306b8d Port: 80/TCP Host Port: 0/TCP State: Running Started: Fri, 09 Oct 2020 15:40:16 +0800 Ready: True Restart Count: 0 Limits: memory: 200Mi Requests: memory: 100Mi Environment: \u003cnone\u003e Mounts: /var/run/secrets/kubernetes.io/serviceaccount from default-token-pvdh5 (ro) Conditions: Type Status Initialized True Ready True ContainersReady True PodScheduled True Volumes: default-token-pvdh5: Type: Secret (a volume populated by a Secret) SecretName: default-token-pvdh5 Optional: false QoS Class: Burstable Node-Selectors: \u003cnone\u003e Tolerations: node.kubernetes.io/not-ready:NoExecute for 300s node.kubernetes.io/unreachable:NoExecute for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled \u003cunknown\u003e default-scheduler Successfully assigned test/nginx-deployment-fbb99c8b8-4lpwd to minikube Normal Pulled 6m31s kubelet, minikube Container image \"nginx:1.14.2\" already present on machine Normal Created 6m31s kubelet, minikube Created container nginx Normal Started 6m31s kubelet, minikube Started container nginx ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:2","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"2.3 更新 deployment 更新镜像，把 nginx 从 1.14.2 升级到 1.19.3 apiVersion:apps/v1# for versions before 1.9.0 use apps/v1beta2kind:Deploymentmetadata:name:nginx-deploymentnamespace:testspec:selector:matchLabels:app:nginxreplicas:2# tells deployment to run 2 pods matching the templatetemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.19.3ports:- containerPort:80应用yaml文件和创建一样. 查看新的 pods: kubectl get pods -l app=nginx --namespace=test NAME READY STATUS RESTARTS AGE nginx-deployment-6b5df77cd8-lf2cl 1/1 Running 0 69s nginx-deployment-6b5df77cd8-n52z6 1/1 Running 0 71s 可以看到和之前的名称都是不一样的. ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:3","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"2.4 改变副本数来弹性伸缩应用 关键参数 replicas 可以设置 pod 的数量，下面例子把 nginx 变成 4 个: apiVersion:apps/v1# for versions before 1.9.0 use apps/v1beta2kind:Deploymentmetadata:name:nginx-deploymentnamespace:testspec:selector:matchLabels:app:nginxreplicas:4# tells deployment to run 2 pods matching the templatetemplate:metadata:labels:app:nginxspec:containers:- name:nginximage:nginx:1.19.3ports:- containerPort:80应用yaml文件和创建一样. 查看新的 pods: kubectl get pods -l app=nginx --namespace=test NAME READY STATUS RESTARTS AGE nginx-deployment-6b5df77cd8-5b28p 1/1 Running 0 65s nginx-deployment-6b5df77cd8-b24xd 1/1 Running 0 65s nginx-deployment-6b5df77cd8-lf2cl 1/1 Running 0 17m nginx-deployment-6b5df77cd8-n52z6 1/1 Running 0 17m dashboard可以直观看到: PodsPods \" Pods ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:4","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"2.5 删除 deployment 通过名称删除deployment: kubectl delete deployment nginx-deployment --namespace=test ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:2:5","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"三、API操作 ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:3:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"四、补充信息 ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:4:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"3.1 ReplicaSet 首先可以看到 nginx 的变化如下图: ReplicaSetReplicaSet \" ReplicaSet 扩容到四个节点后: ReplicaSetReplicaSet \" ReplicaSet ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:4:1","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"五、参考 https://kubernetes.io/zh/docs/tasks/run-application/run-stateless-application-deployment/ https://kubernetes.io/zh/docs/concepts/workloads/controllers/deployment/ https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/ https://github.com/kubernetes/client-go ","date":"2020-10-09","objectID":"/2020/10/run-deployment/:5:0","tags":["deployment","pod"],"title":"一拳搞定 Kubernetes | 走近 deployment","uri":"/2020/10/run-deployment/"},{"categories":["kubernetes"],"content":"本文介绍如何在本机mac运行 Minikube 来学习 kubernetes. ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:0:0","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"一、前言 ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:1:0","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"二、Minikube 操作 ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:0","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"2.1 暂停 Minikube minikube stop 输出: * Stopping \"minikube\" in hyperkit ... * \"minikube\" 已停止 ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:1","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"2.2 启动 minikube start 输出: * Darwin 10.15.6 上的 minikube v1.6.2 - KUBECONFIG=/Users/tc/.kube/config.22 * Selecting 'hyperkit' driver from existing profile (alternates: []) * Tip: Use 'minikube start -p \u003cname\u003e' to create a new cluster, or 'minikube delete' to delete this one. * Starting existing hyperkit VM for \"minikube\" ... * Waiting for the host to be provisioned ... ^[* 正在 Docker '19.03.5' 中准备 Kubernetes v1.17.0… * 正在启动 Kubernetes ... * 完成！kubectl 已经配置至 \"minikube\" ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:2","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"2.3 启动 dashboard minikube dashboard 输出: * Verifying dashboard health ... * Launching proxy ... * Verifying proxy health ... * Opening http://127.0.0.1:58368/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/ in your default browser... ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:3","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"2.4 查看 service 的 URL minikube service hello-minikube --url ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:4","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"2.5 删除 Minikube 集群 minikube delete 输出: * Deleting \"minikube\" ... * The \"minikube\" cluster has been deleted. ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:2:5","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"三、碰到的问题 在电脑从公司带回家再次来到公司的时候，出现了一些网络问题，比如 dashboard 无法打开，在浏览器回车 dashboard 地址(http://127.0.0.1:63999/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/service?namespace=default)后返回: { \"kind\": \"Status\", \"apiVersion\": \"v1\", \"metadata\": { }, \"status\": \"Failure\", \"message\": \"no endpoints available for service \\\"http:kubernetes-dashboard:\\\"\", \"reason\": \"ServiceUnavailable\", \"code\": 503 } 这时候建议 stop minikube 后再重新启动. ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:3:0","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["kubernetes"],"content":"四、参考 https://kubernetes.io/zh/docs/setup/learning-environment/minikube/ ","date":"2020-10-09","objectID":"/2020/10/k8s-local-minikube-01/:4:0","tags":["minikube"],"title":"一拳搞定 Kubernetes | 玩转 Minikube","uri":"/2020/10/k8s-local-minikube-01/"},{"categories":["领域驱动"],"content":"本文介绍一个实际项目中可以使用的概念: Domain Primitive. ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:0:0","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"一、前言 领域驱动这个概念也听到很多次了,书上看过的已经忘记,道听途说的不敢苟同（自己也分不清真假,听闻也没一个真正”成功“的案例）,这里我就说一句我的理解:深入挖掘业务内核,找到问题的根本,把复杂问题分为多个领域（领域内聚）去解决业务实际的问题,而不是通过技术角度随着岁月留下一堆跳跃的代码. ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:1:0","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"二、本文主角 Domain Primitive ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:2:0","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"2.1 Domain Primitive 的定义 概念 不从任何其他事物发展而来 初级的形成或生长的早期阶段 让我们重新来定义一下 Domain Primitive :Domain Primitive 是一个在特定领域里,拥有精准定义的、可自我验证的、拥有行为的 Value Object . • DP是一个传统意义上的Value Object,拥有Immutable的特性 • DP是一个完整的概念整体,拥有精准定义 • DP使用业务域中的原生语言 • DP可以是业务域的最小组成部分、也可以构建复杂组合 注意:Domain Primitive的概念和命名来自于Dan Bergh Johnsson \u0026 Daniel Deogun的书 Secure by Design. ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:2:1","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"2.2 使用 Domain Primitive 的三原则 • 让隐性的概念显性化 • 让隐性的上下文显性化 • 封装多对象行为 ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:2:2","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"2.3 Domain Primitive 和 DDD 里 Value Object 的区别 在 DDD 中, Value Object 这个概念其实已经存在: • 在 Evans 的 DDD 蓝皮书中,Value Object 更多的是一个非 Entity 的值对象 • 在Vernon的IDDD红皮书中,作者更多的关注了Value Object的Immutability、Equals方法、Factory方法等 Domain Primitive 是 Value Object 的进阶版,在原始 VO 的基础上要求每个 DP 拥有概念的整体,而不仅仅是值对象.在 VO 的 Immutable 基础上增加了 Validity 和行为.当然同样的要求无副作用（side-effect free）. ▍Domain Primitive 和 Data Transfer Object (DTO) 的区别 在日常开发中经常会碰到的另一个数据结构是 DTO ,比如方法的入参和出参.DP 和 DTO 的区别如下: DTO DP 功能 数据传输属于技术细节 业务领域中的概念 数据的关联 只是一堆数据放在一起不一定有关联度 数据之间的高相关新 行为 无行为 丰富的行为和业务逻辑 ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:2:3","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"2.4 什么情况下应该用 Domain Primitive 常见的 DP 的使用场景包括: • 有格式限制的 String:比如Name,PhoneNumber,OrderNumber,ZipCode,Address等 • 有限制的Integer:比如OrderId（\u003e0）,Percentage（0-100%）,Quantity（\u003e=0）等 • 可枚举的 int :比如 Status（一般不用Enum因为反序列化问题） • Double 或 BigDecimal:一般用到的 Double 或 BigDecimal 都是有业务含义的,比如 Temperature、Money、Amount、ExchangeRate、Rating 等 • 复杂的数据结构:比如 Map\u003e 等,尽量能把 Map 的所有操作包装掉,仅暴露必要行为 ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:2:4","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"三、项目的的尝试 举例子: DP对象 @Getter @JSONType(deserializer = NameDeserializer.class, serializer = NameSerializer.class) public class Name implements Serializable { private static final long serialVersionUID = 7482387369308807214L; private final String name; public Name(final String name) { if (StringUtils.isBlank(name)) { throw new ValidationException(\"名称不能为空!!!\"); } if (!isValid(name)) { throw new ValidationException(\"仅支持1-64位大小写字母,数字,中划线和下划线组成,必须字母开头!!!\"); } this.name = name; } private static boolean isValid(String code) { String pattern = \"^[a-zA-Z][a-zA-Z0-9_-]{1,64}$\"; return code.matches(pattern); } } 领域方法 // 根据应用和Git信息查询流水线发布记录 public PipelineDO queryByAppAndGit(final Name appName, final Git git) { // 进行逻辑处理 } 说明 final 修饰字段,不可变性的特点 构造方法就直接校验合法性,不需要factory和validutil,更内聚自己的功能 因为存在JSON序列化和反序列的情况,这里需要自定义序列化和反序列的方法 效果 前端联调企图传随便的内容进来,直接通不过参数校验,就进不到核心方法了 参数相对更能直观其意,并且进来的参数值取出来肯定是合法的 代码可以写的更少 容易出错的地方 如果用Map做一个缓存,Key放String,而实际对应的是Code对象,那么查询的时候要用code.genCodeString(),一开始容易写code忘记转换,导致查询不到结果 JSON转换在上面已经提到了需要自己定义扩展,会增加一定的重复代码量（我们暂时用的是每个DP类型两个转换类,可以合并到一个方法,根据类型判断,但是语义不够清晰 还没做好的地方 如果通过jar包提供给第三方接口调用也使用这个DP类,那么接口调用方传参不合法的时候就会报错 ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:3:0","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["领域驱动"],"content":"四、参考 阿里云领域驱动DP文章 ","date":"2020-05-28","objectID":"/2020/05/domain-primitive/:4:0","tags":["DDD","值对象"],"title":"领域驱动实战 | Domain Primitive 的简单使用","uri":"/2020/05/domain-primitive/"},{"categories":["设计模式"],"content":"本文介绍如何在 go 语言中使用模板模式. ","date":"2019-11-09","objectID":"/2019/11/pattern-template/:0:0","tags":["golang","模板模式"],"title":"模板模式","uri":"/2019/11/pattern-template/"},{"categories":["设计模式"],"content":"一、前言 Template Pattern（模板模式） 白话文: 定一个“抽象类”,定义一个方法A,定义需要子类实现的方法,所有子类对象在执行A的时候,会调用各自实现的方法. 在golang中,由于不存在抽象类和真正的继承,所以只能通过一个基础类来充当抽象类,子类通过组合基础类来实现通用方法的继承. 故事: 阳光明媚的一天,我家来了位香港的朋友（毕竟那边太乱）,我们决定一起做一桌菜,于是他做香港菜,我做杭州菜,比拼就这么开始了. ","date":"2019-11-09","objectID":"/2019/11/pattern-template/:1:0","tags":["golang","模板模式"],"title":"模板模式","uri":"/2019/11/pattern-template/"},{"categories":["设计模式"],"content":"二、实例 ","date":"2019-11-09","objectID":"/2019/11/pattern-template/:2:0","tags":["golang","模板模式"],"title":"模板模式","uri":"/2019/11/pattern-template/"},{"categories":["设计模式"],"content":"2.1 普通例子 代码 package main import ( \"fmt\" \"testing\" ) type Cooking interface { DoOperate() } type AbstractCooking struct { Cooking Prepare func() GetContent func() string } func (d AbstractCooking) DoOperate() { d.Prepare() fmt.Println(\"烹饪内容:\", d.GetContent()) fmt.Println(\"烹饪完成\") } type HZCooking struct { AbstractCooking } func NewHZCooking() *HZCooking { c := new(HZCooking) c.AbstractCooking.GetContent = c.GetContent c.AbstractCooking.Prepare = c.Prepare return c } func (c *HZCooking) GetContent() string { return \"杭州菜.\" } func (c *HZCooking) Prepare() { fmt.Println(\" -- 准备杭州菜 -- \") } type HkCooking struct { HZCooking } func NewHKCooking() *HkCooking { c := new(HkCooking) c.AbstractCooking.GetContent = c.GetContent c.AbstractCooking.Prepare = c.Prepare return c } func (c *HkCooking) GetContent() string { return \"香港菜.\" } func (c *HkCooking) Prepare() { fmt.Println(\" -- 准备香港菜 -- \") } func TestCooking(t *testing.T) { chinaCooking := NewHZCooking() chinaCooking.DoOperate() hkCooking := NewHKCooking() hkCooking.DoOperate() } 输出结果: -- 准备杭州菜 -- 烹饪内容: 杭州菜. 烹饪完成 -- 准备香港菜 -- 烹饪内容: 香港菜. 烹饪完成 ","date":"2019-11-09","objectID":"/2019/11/pattern-template/:2:1","tags":["golang","模板模式"],"title":"模板模式","uri":"/2019/11/pattern-template/"},{"categories":["设计模式"],"content":"三、参考 https://www.tutorialspoint.com/design_pattern/template_pattern.htm ","date":"2019-11-09","objectID":"/2019/11/pattern-template/:3:0","tags":["golang","模板模式"],"title":"模板模式","uri":"/2019/11/pattern-template/"},{"categories":["设计模式"],"content":"本文介绍在 go 语言中使用装饰者模式. ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:0:0","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["设计模式"],"content":"一、前言 Decorator Pattern（装饰模式） 维基百科 This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact. 白话文: 这个模式我们需要创建一个新的装饰类,然后装饰类会拥有一个属性是被装饰类,并且会有“一个”方法和需要使用的被装饰类的方法签名完全一致,调用装饰类的方法会执行装饰类内容并调用被装饰类的被装饰方法. 故事: 我买了一本书《go编程思想》,小明也买了一本书《go编程思想》并给它带上了一个黄金封面,两本书内容一摸一样,只是小明的变成金灿灿的土豪版. ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:1:0","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["设计模式"],"content":"二、实例 ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:2:0","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["设计模式"],"content":"2.1 对于某个接口的方法装饰 代码: package decorator import ( \"fmt\" \"testing\" ) type Shape interface { draw() } type Circle struct { } func (shape Circle) draw() { fmt.Println(\"Shape: Circle\") } type Rectangle struct { } func (shape Rectangle) draw() { fmt.Println(\"Shape: Rectangle\") } type ShapeDecorator struct { decoratorShape Shape } func (shape ShapeDecorator) draw() { shape.decoratorShape.draw() } type RedShapeDecorator struct { ShapeDecorator } func NewRedShapeDecorator(s Shape) *RedShapeDecorator { d := new(RedShapeDecorator) d.decoratorShape = s return d } func (shape RedShapeDecorator) draw() { shape.ShapeDecorator.draw() fmt.Println(\"red\") } type BlueShapeDecorator struct { ShapeDecorator } func NewBlueShapeDecorator(s Shape) *BlueShapeDecorator { d := new(BlueShapeDecorator) d.decoratorShape = s return d } func (shape BlueShapeDecorator) draw() { shape.ShapeDecorator.draw() fmt.Println(\"blue\") } func TestName(t *testing.T) { redShapedDecorator := NewRedShapeDecorator(Circle{}) redShapedDecorator.draw() redShapedDecorator = NewRedShapeDecorator(Rectangle{}) redShapedDecorator.draw() blueShapedDecorator := NewBlueShapeDecorator(Circle{}) blueShapedDecorator.draw() blueShapedDecorator = NewBlueShapeDecorator(Rectangle{}) blueShapedDecorator.draw() } 输出结果: Shape: Circle red Shape: Rectangle red Shape: Circle blue Shape: Rectangle blue ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:2:1","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["设计模式"],"content":"2.2 直接装饰方法 代码: type drawFunc func() func CircleDraw() { fmt.Println(\"Shape: Circle\") } func RedCircleDraw(d drawFunc) drawFunc { return func() { d() fmt.Println(\"red\") } } func TestFunc(t *testing.T) { var drawFunc drawFunc drawFunc = CircleDraw drawFunc() drawFunc = RedCircleDraw(drawFunc) drawFunc() } 输出结果: Shape: Circle Shape: Circle red ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:2:2","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["设计模式"],"content":"三、参考 https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm ","date":"2019-11-04","objectID":"/2019/11/pattern-decorator/:3:0","tags":["golang","装饰者模式"],"title":"装饰者模式","uri":"/2019/11/pattern-decorator/"},{"categories":["阿里云"],"content":"本文介绍阿里云数据库 binglog 配置注意点. ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:0:0","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"一、前言 上周同事负责的同步服务出现宕机后,由于在忙于另一个重要的项目,线上没有及时处理,后发现同步数据丢失.我趁机了解了下我们的同步逻辑并对这次异常做一个简单的总结. 情况描述: 线上我们基于 otter 的 msyql 数据同步服务出错,出错后会停止数据同步（我们后续的配置没有从中心节点同步到私有云节点）,导致了私有云无法正常启动部分服务. 我们分阿里云（中心节点）,北京私有云节点,广州私有云节点等,数据会从中心节点同步到私有云节点 中心节点使用了阿里云的RDS MySQL数据库,私有云节点采用自己搭建的MySQL 采用基于otter的数据同步服务（otter基于canal） 我们采用了xxl-job来做定时调度,因为之前认为它只有DML操作,我们的同步服务没有对它的DDL操作做处理 xxl-job的机器配置的较低,数据量变大之后XXL_JOB_QRTZ_TRIGGER_LOG的查询语句运行较慢,我们给它增加了个索引 我们的同步服务异常后,会停止数据同步 A服务发布,在中心节点加了配置,私有云节点启动失败 查询发现同步服务异常,无法通过binlog的偏移量找到记录,导致无法把中心节点加了的配置同步到私有云节点 我们是在一天后对这个问题做的处理 ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:1:0","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"二、排查 ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:2:0","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"2.1 xxl job的变化 xxl-job的SQL: SELECT t.id, t.job_group, t.job_id, t.executor_address, t.executor_handler , t.executor_param, t.executor_sharding_param, t.executor_fail_retry_count, t.trigger_time, t.trigger_code , t.trigger_msg, t.handle_time, t.handle_code, t.handle_msg FROM XXL_JOB_QRTZ_TRIGGER_LOG t WHERE t.job_group = ? AND t.job_id = ? AND t.trigger_time \u003e= ? AND t.trigger_time \u003c= ? ORDER BY id DESC LIMIT ?, ? 并没有异常情况. ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:2:1","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"2.2 MySQL 排查 mysql 查看 binlog: // 查看binlog文件列表 mysql\u003e show binary logs; +------------------+-----------+ | Log_name | File_size | +------------------+-----------+ | mysql-bin.000001 | 107853 | +------------------+-----------+ 1 row in set (0.00 sec) // 查看binlog状态 mysql\u003e show master status; +------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +------------------+----------+--------------+------------------+-------------------+ | mysql-bin.000001 | 107853 | | | | +------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) 并没有异常情况. ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:2:2","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"三、解决方案 因为同步服务是由于binlog的偏移量问题而失败,偏移量是通过zk节点去获取的,我们去MySQL查询了最新的可用的偏移量,设置到了zk的指定节点,让同步服务正常运行.（我们的配置同步在新偏移量之后,所以启动后能够从中心节点同步到私有云节点） 这个是临时的解决方案,我们没法找到之前的binlog的完整记录 ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:3:0","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"四、思考问题 ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:4:0","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"4.1 为什么过了一天,同步服务会启动失败？ 同步服务失败,因为binlog找不到.MySQL我们自己安装的话binlog配置默认是不清理的,但是RDS上不是这样的. 下面是RDS默认配置: 保留时长:默认值为18,表示实例空间内默认保存最近18个小时内的Binlog文件,18个小时之前的日志将在备份后（需要开启日志备份）清理.保留时长可选范围值为0~7*24小时. 空间使用率不超过:默认值为30%,表示本地Binlog空间使用率大于30%时,系统会从最早的Binlog开始清理,直到空间使用率低于30%.空间使用率不超过可选范围值为0 - 50% . 可用空间保护,默认开启该功能,表示当实例总空间使用率超过80%或实例剩余可用空间不足5GB时,会强制从最早的Binlog开始清理,直到总空间使用率降到80%以下且实例剩余可用空间大于5GB. 我们可以看到RDS默认保留时间小于一天,所以我们停了一天后再度开启,导致binlog位置找不到,只能从最新的偏移量同步.这里首先把保留时长调至3天（我们的同步服务不可能停3天,在某些改造项目,同步服务可能会停1-2天）,这个需要根据实际场景去设置合理的值. ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:4:1","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":["阿里云"],"content":"4.2 binlog不在了,如何补救？ 阿里云会把binlog保存到OSS,从OSS下载回来binlog,然后把binlog设置到MySQL指定位置（这块可能是我脑补的）.这块有任何问题可以提工单,毕竟顾客是“上帝”. 本地验证的时候,位置是: /usr/local/mysql/data ","date":"2019-09-22","objectID":"/2019/09/aliyun-daily-01/:4:2","tags":["RDS","MySQL","binlog","otter","canal"],"title":"阿里云采坑记录 | RDS 的 binglog 丢失","uri":"/2019/09/aliyun-daily-01/"},{"categories":null,"content":"一个对 Java，Go，云原生和微服务感兴趣的开发人员。 联系我： 邮箱：tczjhz@163.com GitHub：cityiron ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]